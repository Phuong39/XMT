package text

import (
	"regexp"
	"strconv"
	"strings"
	"sync"

	"github.com/iDigitalFlame/xmt/util"
)

var (
	// MatchAny is a Matcher that can be used to match any string or byte array.
	MatchAny anyRegexp
	// MatchNone is a Matcher that can be used to NOT match any string or byte
	// array.
	MatchNone falseRegexp

	builders = sync.Pool{
		New: func() interface{} {
			return new(util.Builder)
		},
	}
)

// String is a wrapper for strings to support the Stringer interface.
type String string

// Matcher is an alias of a string that can contain specific variable
// instructsions to be replaced when calling the 'String' function. This alias
// provides the 'Match' function, which returns a Regexp struct that will match
// any value generated.
//
// Matcher Verb Guide
//
// <N> indicates a non-negative number value that is REQUIRED.
// [N] indicated a non-negative number value that is OPTIONAL.
//      - If omitted, a random positive 8 to 32bit value will be used.
//
// If the number is followed by a 'f', this will FORCE the count and will use it
// directly instead of a range to N. Otherwise, a [1, N] (inclusive) value will
// be generated to be used instead.
//
// In both cases, the '<', '[', ']', and '>' are only used to cannotate usage,
// and not actually used in the string value.
//
// | Verb   | Description                                         | RegEx            |
// | ====== | =================================================== | ================ |
// | %<N>n  | 1 to N count of random single-digit numbers         | [0-9]{1,N}       |
// | %<N>fn | N count of random single-digit numbers              | [0-9]{N}         |
// | %<N>c  | 1 to N count of random ASCII non-number characters  | [a-zA-Z]{1,N}    |
// | %<N>fc | N count of random ASCII non-number characters       | [a-zA-Z]{N}      |
// | %<N>u  | 1 to N count of random ASCII uppercase characters   | [A-Z]{1,N}       |
// | %<N>fu | N count of random ASCII uppercase characters        | [A-Z]{N}         |
// | %<N>l  | 1 to N count of random ASCII lowercase characters   | [a-z]{1,N}       |
// | %<N>fl | N count of random ASCII lowercase characters        | [a-z]{n}         |
// | %s     | Random 1 to 256 count of random ASCII characters    | ([a-zA-Z0-9]+)   |
// | %[N]s  | 1 to N (or random) count of random ASCII characters | [a-zA-Z0-9]{1,N} |
// | %<N>fs | N count of random ASCII characters                  | [a-zA-Z0-9]{N}   |
// | %d     | String literal number 0 to 4,294,967,296            | ([0-9]+)         |
// | %<N>d  | String literal number 0 to N                        | ([0-9]+)         |
// | %<N>fd | String literal number N                             | ([0-9]+)         |
// | %h     | Hex string literal number 0 to 4,294,967,296        | ([a-fA-F0-9]+)   |
// | %<N>h  | Hex string literal number 0 to N                    | ([a-fA-F0-9]+)   |
// | %<N>fh | Hex string literal number N                         | ([a-fA-F0-9]+)   |
//
// All other values are ignored and directly added to the resulting string value.
type Matcher string
type anyRegexp struct{}

// Regexp is a compatibility interface that is used to allow for UnMatch values
// to be used lacking the ability of RE2 used in Golang to do negative lookahead.
type Regexp interface {
	String() string
	Match([]byte) bool
	MatchString(string) bool
}
type falseRegexp struct{}
type inverseRegexp string

// Raw returns the raw string value of this Matcher without preforming any
// replacements.
func (s Matcher) Raw() string {
	return string(s)
}

// String returns the string value of itself.
func (s String) String() string {
	return string(s)
}

// Match returns a valid Regexp struct that is guaranteed to match any string
// generated by the  Matcher's 'String' function.
func (s Matcher) Match() Regexp {
	return s.MatchEx(true)
}

// String parses this MatchString value and will preform any replacements and
// fill any variables contained.
func (s Matcher) String() string {
	if len(s) == 0 {
		return string(s)
	}
	m := regxBuild.FindAllStringSubmatchIndex(string(s), -1)
	if len(m) == 0 {
		return string(s)
	}
	var (
		l   int
		err error
		b   = builders.Get().(*util.Builder)
	)
	b.Grow(len(s))
	for x, v, c := 0, 0, ""; x < len(m); x++ {
		if m[x][0] < 0 || m[x][1] < m[x][0] {
			continue
		}
		if m[x][4] > 0 && m[x][5] > m[x][4] {
			if s[m[x][5]-1] == 'f' {
				v, err = strconv.Atoi(string(s[m[x][4] : m[x][5]-1]))
			} else {
				v, err = strconv.Atoi(string(s[m[x][4]:m[x][5]]))
			}
			if err != nil {
				v = -1
			}
		} else {
			v = -1
		}
		switch {
		case s[m[x][1]-1] == 'n' && s[m[x][1]-2] == 'f' && v > 0:
			c = Rand.StringNumber(v)
		case s[m[x][1]-1] == 'c' && s[m[x][1]-2] == 'f' && v > 0:
			c = Rand.StringCharacters(v)
		case s[m[x][1]-1] == 'u' && s[m[x][1]-2] == 'f' && v > 0:
			c = Rand.StringUpper(v)
		case s[m[x][1]-1] == 'l' && s[m[x][1]-2] == 'f' && v > 0:
			c = Rand.StringLower(v)
		case s[m[x][1]-1] == 's' && s[m[x][1]-2] == 'f' && v > 0:
			c = Rand.String(v)
		case s[m[x][1]-1] == 'd' && s[m[x][1]-2] == 'f' && v >= 0:
			c = strconv.Itoa(v)
		case s[m[x][1]-1] == 'h' && s[m[x][1]-2] == 'f' && v >= 0:
			c = strconv.FormatInt(int64(v), 16)
		case s[m[x][1]-1] == 'd' && v >= 0:
			c = strconv.Itoa(int(util.FastRandN(v)))
		case s[m[x][1]-1] == 'h' && v >= 0:
			c = strconv.FormatInt(int64(util.FastRandN(v)), 16)
		case s[m[x][1]-1] == 'n' && v > 0:
			c = Rand.StringNumberRange(1, v)
		case s[m[x][1]-1] == 'c' && v > 0:
			c = Rand.StringCharactersRange(1, v)
		case s[m[x][1]-1] == 'u' && v > 0:
			c = Rand.StringUpperRange(1, v)
		case s[m[x][1]-1] == 'l' && v > 0:
			c = Rand.StringLowerRange(1, v)
		case s[m[x][1]-1] == 's' && v > 0:
			c = Rand.StringRange(1, v)
		case s[m[x][1]-1] == 's':
			c = Rand.StringRange(1, 1+int(util.FastRandN(256)))
		case s[m[x][1]-1] == 'd':
			c = strconv.Itoa(int(util.FastRand()))
		case s[m[x][1]-1] == 'h':
			c = strconv.FormatInt(int64(util.FastRand()), 16)
		default:
			c = string(s[m[x][0]:m[x][1]])
		}
		b.WriteString(string(s[l:m[x][0]]))
		b.WriteString(c)
		c, l = "", m[x][1]
	}
	if l < len(s) {
		b.WriteString(string(s[l:]))
	}
	o := b.String()
	b.Reset()
	builders.Put(b)
	return o
}
func (anyRegexp) String() string {
	return "*"
}

// UnMatch returns a valid Regexp struct that is guaranteed to not match any
// string generated by the Matcher's 'String' function.
func (s Matcher) UnMatch() Regexp {
	return s.MatchEx(false)
}
func (falseRegexp) String() string {
	return "false"
}
func (anyRegexp) Match(_ []byte) bool {
	return true
}
func (i inverseRegexp) String() string {
	return string(i)
}

// MatchEx returns a valid Regexp struct that is guaranteed to match any string
// generated by the Matcher's 'String' function. MatchEx returns an inverse
// matcher if the bool is false.
func (s Matcher) MatchEx(o bool) Regexp {
	if len(s) == 0 {
		return MatchAny
	}
	if s == "*" {
		return MatchAny
	}
	m := regxBuild.FindAllStringSubmatchIndex(string(s), -1)
	if len(m) == 0 {
		if !o {
			return inverseRegexp(s)
		}
		if r, err := regexp.Compile(`^(` + regexp.QuoteMeta(string(s)) + `)$`); err == nil {
			return r
		}
		return MatchNone
	}
	var (
		l   int
		d   string
		err error
		b   = builders.Get().(*util.Builder)
	)
	if b.WriteString("^("); !o {
		d = "^"
	}
	for x, v, c, q := 0, 0, "", ""; x < len(m); x++ {
		if m[x][0] < 0 || m[x][1] < m[x][0] {
			continue
		}
		if m[x][4] > 0 && m[x][5] > m[x][4] {
			if s[m[x][5]-1] == 'f' {
				v, err = strconv.Atoi(string(s[m[x][4] : m[x][5]-1]))
			} else {
				v, err = strconv.Atoi(string(s[m[x][4]:m[x][5]]))
			}
			if err != nil {
				v, q = -1, "0"
			} else {
				q = strconv.Itoa(v)
			}
		} else {
			v = -1
		}
		switch {
		case s[m[x][1]-1] == 'd':
			c = `([` + d + `0-9]+)`
		case s[m[x][1]-1] == 'h':
			c = `([` + d + `a-fA-F0-9]+)`
		case s[m[x][1]-1] == 'n' && s[m[x][1]-2] == 'f' && v > 0:
			c = `([` + d + `0-9]{` + q + `})`
		case s[m[x][1]-1] == 'c' && s[m[x][1]-2] == 'f' && v > 0:
			c = `([` + d + `a-zA-Z]{` + q + `})`
		case s[m[x][1]-1] == 'u' && s[m[x][1]-2] == 'f' && v > 0:
			c = `([` + d + `A-Z]{` + q + `})`
		case s[m[x][1]-1] == 'l' && s[m[x][1]-2] == 'f' && v > 0:
			c = `([` + d + `a-z]{` + q + `})`
		case s[m[x][1]-1] == 's' && s[m[x][1]-2] == 'f' && v > 0:
			c = `([` + d + `a-zA-Z0-9]{` + q + `})`
		case s[m[x][1]-1] == 'n' && v > 0:
			c = `([` + d + `0-9]{1,` + q + `})`
		case s[m[x][1]-1] == 'c' && v > 0:
			c = `([` + d + `a-zA-Z]{1,` + q + `})`
		case s[m[x][1]-1] == 'u' && v > 0:
			c = `([` + d + `A-Z]{1,` + q + `})`
		case s[m[x][1]-1] == 'l' && v > 0:
			c = `([` + d + `a-z]{1,` + q + `})`
		case s[m[x][1]-1] == 's' && v > 0:
			c = `([` + d + `a-zA-Z0-9]{1,` + q + `})`
		case s[m[x][1]-1] == 's':
			c = `([` + d + `a-zA-Z0-9]+)`
		default:
			c = string(s[m[x][0]:m[x][1]])
		}
		b.WriteString(strings.ReplaceAll(regexp.QuoteMeta(string(s[l:m[x][0]])), "/", "\\/"))
		b.WriteString(c)
		l = m[x][1]
	}
	if l < len(s) {
		b.WriteString(strings.ReplaceAll(regexp.QuoteMeta(string(s[l:])), "/", "\\/"))
	}
	b.WriteString(")$")
	r, err := regexp.Compile(b.Output())
	if builders.Put(b); err != nil {
		return MatchAny
	}
	return r
}
func (falseRegexp) Match(_ []byte) bool {
	return false
}
func (anyRegexp) MatchString(_ string) bool {
	return true
}
func (i inverseRegexp) Match(b []byte) bool {
	return string(i) != string(b)
}
func (falseRegexp) MatchString(_ string) bool {
	return false
}
func (i inverseRegexp) MatchString(s string) bool {
	return string(i) != s
}
