package util

import (
	"bytes"
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"sync"
)

const (
	matchNum         = "([%c0-9]+)"
	matchHex         = "([%ca-f0-9]+)"
	matchLower       = "([%ca-z]+)"
	matchUpper       = "([%cA-Z]+)"
	matchChars       = "([%ca-zA-Z]+)"
	matchString      = "([%ca-zA-Z0-9]+)"
	matchSingle      = "^(%s)$"
	matchNumFixed    = "([%c0-9]{%d})"
	matchNumRange    = "([%c0-9]{1,%d})"
	matchCharsFixed  = "([%ca-zA-Z]{%d})"
	matchLowerFixed  = "([%ca-z]{%d})"
	matchUpperFixed  = "([%cA-Z]{%d})"
	matchCharsRange  = "([%ca-zA-Z]{1,%d})"
	matchLowerRange  = "([%ca-z]{1,%d})"
	matchUpperRange  = "([%cA-Z]{1,%d})"
	matchStringRange = "([%ca-zA-Z0-9]{1,%d})"
	matchStringFixed = "([%ca-zA-Z0-9]{%d})"
)

var (
	builders = &sync.Pool{
		New: func() interface{} {
			return new(strings.Builder)
		},
	}

	regxFalse = falseRegexp(false)
	regxBuild = regexp.MustCompile("(\\%(\\d+f?)?[dhcsuln])")
)

// Matcher is an alias of a string that can
// contain specific variable instructsions to be
// replaced when calling the 'String' function.
// This alias provides the 'Match' function, which returns
// a Regexp struct that will match any value generated.
type Matcher string
type falseRegexp bool

// Regexp is a compatibility interface that is used
// to allow for UnMatch values to be used lacking the ability
// of RE2 used in Golang to do negative lookahead.
type Regexp interface {
	String() string
	Match([]byte) bool
	MatchString(string) bool
}
type inverseRegexp string

// Match returns a valid Regexp struct that is guaranteed
// to match any string generated by the Matcher's 'String' function.
func (s Matcher) Match() Regexp {
	return s.MatchEx(true)
}

// String parses this MatchString value and will preform
// any replacements and fill any variables contained.
func (s Matcher) String() string {
	if len(s) == 0 {
		return string(s)
	}
	m := regxBuild.FindAllStringSubmatchIndex(string(s), -1)
	if m == nil || len(m) == 0 {
		return string(s)
	}
	b := builders.Get().(*strings.Builder)
	defer resetBuffer(b)
	var l int
	var i int64
	var err error
	for x, v, c := 0, 0, ""; x < len(m); x++ {
		if m[x][0] < 0 || m[x][1] < m[x][0] {
			continue
		}
		if m[x][4] > 0 && m[x][5] > m[x][4] {
			if s[m[x][5]-1] == 'f' {
				i, err = strconv.ParseInt(string(s[m[x][4]:m[x][5]-1]), 10, 32)
			} else {
				i, err = strconv.ParseInt(string(s[m[x][4]:m[x][5]]), 10, 32)
			}
			if err == nil {
				v = int(i)
			} else {
				v = -1
			}
		} else {
			v = -1
		}
		switch {
		case s[m[x][1]-1] == 'n' && s[m[x][1]-2] == 'f' && v > 0:
			c = Rand.StringNumber(v)
		case s[m[x][1]-1] == 'c' && s[m[x][1]-2] == 'f' && v > 0:
			c = Rand.StringCharacters(v)
		case s[m[x][1]-1] == 'u' && s[m[x][1]-2] == 'f' && v > 0:
			c = Rand.StringUpper(v)
		case s[m[x][1]-1] == 'l' && s[m[x][1]-2] == 'f' && v > 0:
			c = Rand.StringLower(v)
		case s[m[x][1]-1] == 's' && s[m[x][1]-2] == 'f' && v > 0:
			c = Rand.String(v)
		case s[m[x][1]-1] == 'd' && s[m[x][1]-2] == 'f' && v >= 0:
			c = strconv.Itoa(v)
		case s[m[x][1]-1] == 'h' && s[m[x][1]-2] == 'f' && v >= 0:
			c = fmt.Sprintf("%x", v)
		case s[m[x][1]-1] == 'd' && v >= 0:
			c = strconv.Itoa(Rand.Intn(v))
		case s[m[x][1]-1] == 'h' && v >= 0:
			c = fmt.Sprintf("%x", Rand.Intn(v))
		case s[m[x][1]-1] == 'n' && v > 0:
			c = Rand.StringNumberRange(1, v)
		case s[m[x][1]-1] == 'c' && v > 0:
			c = Rand.StringCharactersRange(1, v)
		case s[m[x][1]-1] == 'u' && v > 0:
			c = Rand.StringUpperRange(1, v)
		case s[m[x][1]-1] == 'l' && v > 0:
			c = Rand.StringLowerRange(1, v)
		case s[m[x][1]-1] == 's' && v > 0:
			c = Rand.StringRange(1, v)
		case s[m[x][1]-1] == 'd':
			c = strconv.Itoa(Rand.Int())
		case s[m[x][1]-1] == 'h':
			c = fmt.Sprintf("%x", Rand.Int())
		}
		b.WriteString(string(s[l:m[x][0]]))
		b.WriteString(c)
		l = m[x][1]
	}
	if l < len(s) {
		b.WriteString(string(s[l:]))
	}
	return b.String()
}

// UnMatch returns a valid Regexp struct that is guaranteed
// to not match any string generated by the Matcher's 'String' function.
func (s Matcher) UnMatch() Regexp {
	return s.MatchEx(false)
}
func resetBuffer(s *strings.Builder) {
	s.Reset()
	builders.Put(s)
}
func (f falseRegexp) String() string {
	return strconv.FormatBool(bool(f))
}
func (i inverseRegexp) String() string {
	return string(i)
}

// MatchEx returns a valid Regexp struct that is guaranteed
// to match any string generated by the Matcher's 'String' function.
// MatchEx returns an inverse matcher if the bool is false
func (s Matcher) MatchEx(o bool) Regexp {
	if len(s) == 0 {
		return regxFalse
	}
	m := regxBuild.FindAllStringSubmatchIndex(string(s), -1)
	if m == nil || len(m) == 0 {
		if !o {
			return inverseRegexp(s)
		}
		if r, err := regexp.Compile(fmt.Sprintf(matchSingle, regexp.QuoteMeta(string(s)))); err == nil {
			return r
		}
		return regxFalse
	}
	b := builders.Get().(*strings.Builder)
	defer resetBuffer(b)
	var l int
	var d rune
	var i int64
	var err error
	if !o {
		d = '^'
	}
	b.WriteString("^(")
	for x, v, c := 0, 0, ""; x < len(m); x++ {
		if m[x][0] < 0 || m[x][1] < m[x][0] {
			continue
		}
		if m[x][4] > 0 && m[x][5] > m[x][4] {
			if s[m[x][5]-1] == 'f' {
				i, err = strconv.ParseInt(string(s[m[x][4]:m[x][5]-1]), 10, 32)
			} else {
				i, err = strconv.ParseInt(string(s[m[x][4]:m[x][5]]), 10, 32)
			}
			if err == nil {
				v = int(i)
			} else {
				v = -1
			}
		} else {
			v = -1
		}
		switch {
		case s[m[x][1]-1] == 'd':
			c = fmt.Sprintf(matchNum, d)
		case s[m[x][1]-1] == 'h':
			c = fmt.Sprintf(matchHex, d)
		case s[m[x][1]-1] == 'n' && s[m[x][1]-2] == 'f' && v > 0:
			c = fmt.Sprintf(matchNumFixed, d, v)
		case s[m[x][1]-1] == 'c' && s[m[x][1]-2] == 'f' && v > 0:
			c = fmt.Sprintf(matchCharsFixed, d, v)
		case s[m[x][1]-1] == 'u' && s[m[x][1]-2] == 'f' && v > 0:
			c = fmt.Sprintf(matchUpperFixed, d, v)
		case s[m[x][1]-1] == 'l' && s[m[x][1]-2] == 'f' && v > 0:
			c = fmt.Sprintf(matchLowerFixed, d, v)
		case s[m[x][1]-1] == 's' && s[m[x][1]-2] == 'f' && v > 0:
			c = fmt.Sprintf(matchStringFixed, d, v)
		case s[m[x][1]-1] == 'n' && v > 0:
			c = fmt.Sprintf(matchNumRange, d, v)
		case s[m[x][1]-1] == 'c' && v > 0:
			c = fmt.Sprintf(matchCharsRange, d, v)
		case s[m[x][1]-1] == 'u' && v > 0:
			c = fmt.Sprintf(matchUpperRange, d, v)
		case s[m[x][1]-1] == 'l' && v > 0:
			c = fmt.Sprintf(matchLowerRange, d, v)
		case s[m[x][1]-1] == 's' && v > 0:
			c = fmt.Sprintf(matchStringRange, d, v)
		case s[m[x][1]-1] == 'n':
			c = fmt.Sprintf(matchNum, d)
		case s[m[x][1]-1] == 'c':
			c = fmt.Sprintf(matchChars, d)
		case s[m[x][1]-1] == 'u':
			c = fmt.Sprintf(matchUpper, d)
		case s[m[x][1]-1] == 'l':
			c = fmt.Sprintf(matchLower, d)
		case s[m[x][1]-1] == 's':
			c = fmt.Sprintf(matchString, d)
		}
		b.WriteString(strings.Replace(regexp.QuoteMeta(string(s[l:m[x][0]])), "/", "\\/", -1))
		b.WriteString(c)
		l = m[x][1]
	}
	if l < len(s) {
		b.WriteString(strings.Replace(regexp.QuoteMeta(string(s[l:])), "/", "\\/", -1))
	}
	b.WriteString(")$")
	if r, err := regexp.Compile(b.String()); err == nil {
		return r
	}
	return regxFalse
}
func (f falseRegexp) Match(_ []byte) bool {
	return bool(f)
}
func (i inverseRegexp) Match(b []byte) bool {
	return !bytes.Equal(b, []byte(i))
}
func (f falseRegexp) MatchString(_ string) bool {
	return bool(f)
}
func (i inverseRegexp) MatchString(s string) bool {
	return string(i) != s
}
